<!DOCTYPE html><html lang="zh-cn,en,default"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Rxswift使用 · winter</title><meta name="description" content="Rxswift使用 - 廖文韬"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="https://winterliao.github.io/atom.xml" title="winter"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">winter</h2></a></div><a href="/" target="_self" class="li component-nav-item"><p>主页</p></a><a href="/archives" target="_self" class="li component-nav-item"><p>归档</p></a><ul class="shortcut-icons"><a href="https://github.com/winterLiao" target="_blank"><img src="/images/github.svg" class="icon"></a></ul></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">Rxswift使用</h1><div class="post-info">2018年8月14日</div><div class="post-content"><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>它拓展了观察者模式。使你能够自由组合多个异步事件，而不需要去关心线程，同步，线程安全，并发数据以及I/O阻塞。     </p>
<h3 id="函数响应式编程"><a href="#函数响应式编程" class="headerlink" title="函数响应式编程"></a>函数响应式编程</h3><ul>
<li>函数式编程：是种编程范式，它需要我们将函数作为参数传递，或者作为返回值返还。我们可以通过组合不同的函数来得到想要的结果。</li>
<li>响应式编程: a=b+c表示将表达式的结果赋给 a，而之后改变 b 或 c的值不会影响 a。但在响应式编程中，a的值会随着 b或 c的更新而更新。a=b+c声明的是一种绑定关系。</li>
</ul>
<h3 id="RxSwift优点"><a href="#RxSwift优点" class="headerlink" title="RxSwift优点"></a>RxSwift优点</h3><ul>
<li>在业务层面实现代码逻辑分离，方便后期维护和拓展</li>
<li>极大提高程序响应速度，充分发掘CPU的能力</li>
<li>帮助开发者提高代码的抽象能力和充分理解业务逻辑</li>
<li>Rx丰富的操作符会帮助我们极大的简化代码逻辑</li>
</ul>
<h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><ul>
<li>Observable - 可被监听的序列产列</li>
<li>Observer - 观察者</li>
<li>Operator - 操作符</li>
<li>Disposable - 管理绑定（订阅）的生命周期</li>
<li>Schedulers - 调度器（线程队列调配）</li>
</ul>
<h3 id="Observable-可被监听的序列"><a href="#Observable-可被监听的序列" class="headerlink" title="Observable - 可被监听的序列"></a>Observable - 可被监听的序列</h3><p>框架已经帮我们创建好了许多常用的序列。例如：button的点击，textField的当前文本，switch的开关状态，slider的当前数值等等。<br><figure class="highlight nginx"><table><tr><td class="code"><pre><div class="line"><span class="attribute">let</span> numbers: Observable&lt;Int&gt; = Observable.create &#123; <span class="attribute">observer</span> -&gt; Disposable in</div><div class="line"></div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">0</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">1</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">2</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">3</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">4</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">5</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">6</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">7</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">8</span>)</div><div class="line">observer.<span class="literal">on</span>Next(<span class="number">9</span>)</div><div class="line">observer.<span class="literal">on</span>Completed()</div><div class="line"></div><div class="line">return Disposables.create()</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Observer-观察者"><a href="#Observer-观察者" class="headerlink" title="Observer - 观察者"></a>Observer - 观察者</h3><p>观察者最直接的方法就是在 Observable 的 subscribe 方法后面描述，事件发生时，需要如何做出响应。而观察者就是由后面的 onNext，onError，onCompleted的这些闭包构建出来的。</p>
<ul>
<li>observer.onNext(0) 就代表产生了一个元素，他的值是 0。</li>
<li>onCompleted()结束</li>
<li>onError()发生错误<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line">tap.subscribe(onNext: &#123; [<span class="keyword">weak</span> <span class="keyword">self</span>] <span class="keyword">in</span></div><div class="line"><span class="keyword">self</span>?.showAlert()</div><div class="line">&#125;, onError: &#123; error <span class="keyword">in</span></div><div class="line"><span class="built_in">print</span>(<span class="string">"发生错误： <span class="subst">\(error.localizedDescription)</span>"</span>)</div><div class="line">&#125;, onCompleted: &#123;</div><div class="line"><span class="built_in">print</span>(<span class="string">"任务完成"</span>)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><ul>
<li><p>filter - 过滤</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 温度</span></div><div class="line">let rxTemperature: Observable&lt;Double&gt; = ...</div><div class="line"></div><div class="line"><span class="comment">// filter 操作符</span></div><div class="line">rxTemperature<span class="selector-class">.filter</span> &#123; temperature <span class="keyword">in</span> temperature &gt; <span class="number">33</span> &#125;</div><div class="line">.subscribe(onNext: &#123; temperature <span class="keyword">in</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"高温：\(temperature)度"</span>)</span></span></div><div class="line">&#125;)</div><div class="line">.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
</li>
<li><p>map - 转换</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> disposeBag = DisposeBag()</div><div class="line">Observable.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</div><div class="line">.<span class="keyword">map</span> &#123; $0 * <span class="number">10</span> &#125;</div><div class="line">.subscribe(onNext: &#123; print($0) &#125;)</div><div class="line">.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
</li>
<li><p>zip - 配对</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><div class="line"><span class="built_in">let</span> disposeBag = DisposeBag()</div><div class="line"><span class="built_in">let</span> <span class="built_in">first</span> = PublishSubject&lt;String&gt;()</div><div class="line"><span class="built_in">let</span> <span class="built_in">second</span> = PublishSubject&lt;String&gt;()</div><div class="line"></div><div class="line">Observable.zip(<span class="built_in">first</span>, <span class="built_in">second</span>) &#123; $<span class="number">0</span> + $<span class="number">1</span> &#125;</div><div class="line">.subscribe(onNext: &#123; <span class="built_in">print</span>($<span class="number">0</span>) &#125;)</div><div class="line">.disposed(by: disposeBag)</div><div class="line"></div><div class="line"><span class="built_in">first</span>.onNext(<span class="string">"1"</span>)</div><div class="line"><span class="built_in">second</span>.onNext(<span class="string">"A"</span>)</div><div class="line">1A</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Disposable-可被清除的资源"><a href="#Disposable-可被清除的资源" class="headerlink" title="Disposable - 可被清除的资源"></a>Disposable - 可被清除的资源</h3><p>通常来说，一个序列如果发出了 error 或者 completed 事件，那么所有内部资源都会被释放。如果你需要提前释放这些资源或取消订阅的话，那么你可以对返回的 可被清除的资源（Disposable） 调用 dispose 方发</p>
<blockquote>
<p>通常情况下，我们不需要手动调用 dispose 方法的 </p>
<p>使用 清除包（DisposeBag） 或者 takeUntil 操作符 来管理订阅的生命周期</p>
<ul>
<li>DisposeBag - 清除包<figure class="highlight swift"><table><tr><td class="code"><pre><div class="line"><span class="keyword">var</span> disposeBag = <span class="type">DisposeBag</span>()</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillAppear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line"><span class="keyword">super</span>.viewWillAppear(animated)</div><div class="line"></div><div class="line">textField.rx.text.orEmpty</div><div class="line">.subscribe(onNext: &#123; text <span class="keyword">in</span> <span class="built_in">print</span>(text) &#125;)</div><div class="line">.disposed(by: <span class="keyword">self</span>.disposeBag)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewWillDisappear</span><span class="params">(<span class="number">_</span> animated: Bool)</span></span> &#123;</div><div class="line"><span class="keyword">super</span>.viewWillDisappear(animated)</div><div class="line"></div><div class="line"><span class="keyword">self</span>.disposeBag = <span class="type">DisposeBag</span>()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
</blockquote>
<ul>
<li>takeUntil<br>使得订阅一直持续到控制器的 dealloc 事件产生为止<figure class="highlight roboconf"><table><tr><td class="code"><pre><div class="line">override func viewDidLoad() &#123;</div><div class="line"><span class="attribute">super.viewDidLoad()</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">_ = usernameValid</div><div class="line">.takeUntil(self.rx.deallocated)</div><div class="line">.bind(to</span>: passwordOutlet<span class="variable">.rx</span><span class="variable">.isEnabled</span>)</div><div class="line"></div><div class="line">_ = usernameValid</div><div class="line"><span class="variable">.takeUntil</span>(self<span class="variable">.rx</span><span class="variable">.deallocated</span>)</div><div class="line"><span class="variable">.bind</span>(to: usernameValidOutlet<span class="variable">.rx</span><span class="variable">.isHidden</span>)</div><div class="line"></div><div class="line">_ = passwordValid</div><div class="line"><span class="variable">.takeUntil</span>(self<span class="variable">.rx</span><span class="variable">.deallocated</span>)</div><div class="line"><span class="variable">.bind</span>(to: passwordValidOutlet<span class="variable">.rx</span><span class="variable">.isHidden</span>)</div><div class="line"></div><div class="line">_ = everythingValid</div><div class="line"><span class="variable">.takeUntil</span>(self<span class="variable">.rx</span><span class="variable">.deallocated</span>)</div><div class="line"><span class="variable">.bind</span>(to: doSomethingOutlet<span class="variable">.rx</span><span class="variable">.isEnabled</span>)</div><div class="line"></div><div class="line">_ = doSomethingOutlet<span class="variable">.rx</span><span class="variable">.tap</span></div><div class="line"><span class="variable">.takeUntil</span>(self<span class="variable">.rx</span><span class="variable">.deallocated</span>)</div><div class="line"><span class="variable">.subscribe</span>(onNext: &#123; [weak self] in self?<span class="variable">.showAlert</span>() &#125;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Schedulers-调度器"><a href="#Schedulers-调度器" class="headerlink" title="Schedulers - 调度器"></a>Schedulers - 调度器</h3><p>Schedulers 是 Rx 实现多线程的核心模块，它主要用于控制任务在哪个线程或队列运行。<br>GCD：<br><figure class="highlight lasso"><table><tr><td class="code"><pre><div class="line"><span class="comment">// 后台取得数据，主线程处理结果</span></div><div class="line">DispatchQueue.<span class="built_in">global</span>(qos: .userInitiated).async &#123;</div><div class="line"><span class="keyword">let</span> <span class="built_in">data</span> = try? <span class="built_in">Data</span>(contentsOf: url)</div><div class="line">DispatchQueue.main.async &#123;</div><div class="line"><span class="built_in">self</span>.<span class="built_in">data</span> = <span class="built_in">data</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>RxSwift:<br><figure class="highlight armasm"><table><tr><td class="code"><pre><div class="line"><span class="symbol">let</span> rxData: Observable&lt;<span class="meta">Data</span>&gt; = ...</div><div class="line"></div><div class="line"><span class="symbol">rxData</span></div><div class="line"><span class="symbol">.subscribeOn</span>(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</div><div class="line"><span class="symbol">.observeOn</span>(MainScheduler.instance)</div><div class="line"><span class="symbol">.subscribe</span>(onNext: &#123; [weak <span class="keyword">self] </span><span class="meta">data</span> in</div><div class="line"><span class="keyword">self?.data </span>= <span class="meta">data</span></div><div class="line">&#125;)</div><div class="line"><span class="symbol">.disposed</span>(<span class="keyword">by: </span>disposeBag)</div></pre></td></tr></table></figure></p>
<ul>
<li>subscribeOn 来决定数据序列的构建函数在哪个 Scheduler 上运行。以上例子中，由于获取 Data 需要花很长的时间，所以用 subscribeOn 切换到 后台 Scheduler 来获取 Data。这样可以避免主线程被阻塞。</li>
<li>observeOn 来决定在哪个 Scheduler 监听这个数据序列。以上例子中，通过使用 observeOn 方法切换到主线程来监听并且处理结果。</li>
<li>MainScheduler 主线程</li>
<li><p>SerialDispatchQueueScheduler<br>抽象了串行 DispatchQueue。如果你需要执行一些串行任务，可以切换到这个 Scheduler 运行。</p>
</li>
<li><p>ConcurrentDispatchQueueScheduler<br>抽象了并行 DispatchQueue。如果你需要执行一些并发任务，可以切换到这个 Scheduler 运行。</p>
</li>
<li><p>OperationQueueScheduler 抽象了 NSOperationQueue。它具备 NSOperationQueue 的一些特点，例如，你可以通过设置 maxConcurrentOperationCount，来控制同时执行并发任务的最大数量。</p>
</li>
</ul>
<h3 id="Error-Handling-错误处理"><a href="#Error-Handling-错误处理" class="headerlink" title="Error Handling - 错误处理"></a>Error Handling - 错误处理</h3><p>RxSwift 主要有两种错误处理机制：</p>
<ul>
<li>retry - 重试</li>
<li>catch - 恢复</li>
</ul>
<h4 id="retry-重试"><a href="#retry-重试" class="headerlink" title="retry - 重试"></a>retry - 重试</h4><ul>
<li>retry<figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">let rxJson: Observable&lt;JSON&gt; = ...</div><div class="line"></div><div class="line">rxJson</div><div class="line">.retry(<span class="number">3</span>)</div><div class="line">.subscribe(onNext: &#123; json <span class="keyword">in</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"取得 JSON 成功: \(json)"</span>)</span></span></div><div class="line">&#125;, onError: &#123; error <span class="keyword">in</span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"取得 JSON 失败: \(error)"</span>)</span></span></div><div class="line">&#125;)</div><div class="line">.disposed(by: disposeBag)</div></pre></td></tr></table></figure>
</li>
</ul>
<p>失败后重试三次</p>
<ul>
<li>retryWhen<br>操作符，这个操作符主要描述应该在何时重试，并且通过闭包里面返回的 Observable 来控制重试的时机：<figure class="highlight kotlin"><table><tr><td class="code"><pre><div class="line">let maxRetryCount = <span class="number">4</span>       <span class="comment">// 最多重试 4 次</span></div><div class="line">let retryDelay: <span class="built_in">Double</span> = <span class="number">5</span>  <span class="comment">// 重试延时 5 秒</span></div><div class="line"></div><div class="line">rxJson</div><div class="line">.retryWhen &#123; (rxError: Observable&lt;Error&gt;) -&gt; Observable&lt;<span class="built_in">Int</span>&gt; <span class="keyword">in</span></div><div class="line"><span class="keyword">return</span> rxError.flatMapWithIndex &#123; (error, index) -&gt; Observable&lt;<span class="built_in">Int</span>&gt; <span class="keyword">in</span></div><div class="line">guard index &lt; maxRetryCount <span class="keyword">else</span> &#123;</div><div class="line"><span class="keyword">return</span> Observable.error(error)</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> Observable&lt;<span class="built_in">Int</span>&gt;.timer(retryDelay, scheduler: MainScheduler.instance)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">.subscribe(...)</div><div class="line">.disposed(<span class="keyword">by</span>: disposeBag)</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="catchError-恢复"><a href="#catchError-恢复" class="headerlink" title="catchError - 恢复"></a>catchError - 恢复</h4><ul>
<li>catchError<br>可以在错误产生时，用一个备用元素或者一组备用元素将错误替换掉：</li>
</ul>
<figure class="highlight lasso"><table><tr><td class="code"><pre><div class="line"><span class="keyword">let</span> rxData: Observable&lt;<span class="built_in">Data</span>&gt; = <span class="params">...</span>      <span class="comment">// 网络请求的数据</span></div><div class="line"><span class="keyword">let</span> cahcedData: Observable&lt;<span class="built_in">Data</span>&gt; = <span class="params">...</span>  <span class="comment">// 之前本地缓存的数据</span></div><div class="line"></div><div class="line">rxData</div><div class="line">.catchError &#123; _ <span class="keyword">in</span> cahcedData &#125;</div><div class="line">.subscribe(onNext: &#123; <span class="built_in">date</span> <span class="keyword">in</span></div><div class="line">print(<span class="string">"获取数据成功: \(date.count)"</span>)</div><div class="line">&#125;)</div><div class="line">.disposed(<span class="keyword">by</span>: disposeBag)</div></pre></td></tr></table></figure>
<ul>
<li>catchErrorJustReturn 当错误产生时，就返回一个空数组，于是就会显示一个空列表页。</li>
</ul>
<h4 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h4><p>展示错误结果<br><figure class="highlight stylus"><table><tr><td class="code"><pre><div class="line">updateUserInfoButton<span class="selector-class">.rx</span><span class="selector-class">.tap</span></div><div class="line">.withLatestFrom(rxUserInfo)</div><div class="line"><span class="selector-class">.flatMapLatest</span> &#123; userInfo -&gt; Observable&lt;Result&lt;Void&gt;&gt; <span class="keyword">in</span></div><div class="line">return update(userInfo)</div><div class="line">.map(Result.success)  <span class="comment">// 转换成 Result</span></div><div class="line"><span class="selector-class">.catchError</span> &#123; error <span class="keyword">in</span> Observable.just(Result.failure(error)) &#125;</div><div class="line">&#125;</div><div class="line">.observeOn(MainScheduler.instance)</div><div class="line">.subscribe(onNext: &#123; result <span class="keyword">in</span></div><div class="line">switch result &#123;           <span class="comment">// 处理 Result</span></div><div class="line">case <span class="selector-class">.success</span>:</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"用户信息更新成功"</span>)</span></span></div><div class="line">case .failure(let error):</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(<span class="string">"用户信息更新失败： \(error.localizedDescription)"</span>)</span></span></div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">.disposed(by: disposeBag)</div></pre></td></tr></table></figure></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>后面会讲下具体实践-UI上的使用，还有更多理论性的东西就看文档就ok了，操作符遇到了再查。<br><a href="https://www.jianshu.com/p/7a6b809bd212">基本常用控件</a><br><a href="https://www.jianshu.com/p/a83eba5e7b8c">UITablView和UICollectionview使用</a><br><a href="https://www.jianshu.com/p/c52dcfde53ca">其他不常用控件</a><br><a href="https://github.com/winterLiao/RxSwiftTest">所有例子demo</a></p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p><a href="http://www.hangge.com/blog/cache/category_72_1.html">swift开发</a><br><a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/">RxSwift中文文档</a></p>
</div></article></div><div id="disqus_thread"></div></div><script>var disqus_shortname = 'Winter';
var disqus_identifier = '2018/08/14/Rxswift使用/';
var disqus_title = 'Rxswift使用';
var disqus_url = 'https://winterliao.github.io/2018/08/14/Rxswift使用/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//Winter.disqus.com/count.js" async></script></main><footer class="footer-container"><div class="paginator"><a href="/2018/08/06/AVPlayer使用/" class="next">下一篇</a></div><div class="copyright"><p>© 2017 - 2018 <a href="https://winterliao.github.io">廖文韬</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"Winter",'auto');ga('send','pageview');</script></body></html>